data MATHD {
  id: mathd_train
  hash: a70e6899859844b9aaa11324db68065b84df502d2d348b24f31bf95bc04f2d79
}

root ROOT {
  expected: {question, type, level}
}

code RETRIEVAL {
  code:
```
_fun = (env) => {
  let l = env['state']['ROOT']['level'];
  let t = env['state']['ROOT']['type'];
  return env['state']['MATHD'].filter((r) => (r['type'] == t && r['level'] == l)).slice(0, 4);
};
```
}

map LOOP {
  from: ROOT
  repeat: 10
}

llm MODEL {
  max_tokens: 1024
  temperature: 0.7
  few_shot_count: 4
  few_shot_prompt:
```
QUESTION: ${RETRIEVAL.problem}
EXPLANATION: ${RETRIEVAL.solution}
ANSWER: ${RETRIEVAL.answer}

```
  prompt:
```
QUESTION: ${LOOP.question}
```
  stop:
```
QUESTION:
```
}

code POSTPROCESS {
  code:
```
_fun = (env) => {
  let completion = env['state']['MODEL']['completion'];
  return {
    "explanation": completion["text"].split("EXPLANATION:")[1].split("\nANSWER:")[0].trim(),
    "answer": completion["text"].split("ANSWER:")[1].trim(),
  };
}
```
}

reduce LOOP { }

code CONSENSUS {
  code:
```
_fun = (env) => {
  let counts = {};
  for d in env['state']['REPEAT'] {
    if d['answer'] not in counts:
      counts[d['answer']] = 0
    counts[d['answer']] += 1
  }
  let answer = env['state']['REPEAT'][0]['answer'];
  let max_count = 0;
  for a in counts.keys() {
    if max_count < counts[a] {
      max_count = counts[a];
      answer = a;
    }
  }
  return { "answer": answer };
};
```
}
